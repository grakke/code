// 一位法国数学家曾编写过一个印度的古老传说：在世界中心贝纳勒斯的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。

// 僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。

// 一个经典的递归问题。我们可以做这样的考虑：
//     先将前63个盘子移动到Y上，确保大盘在小盘下。
//     再将最底下的第64个盘子移动到Z上。
//     最后将Y上的63个盘子移动到Z上。
//     接下来，要做的就是将Y上的前62个盘子借助Z移动到X上，再将最底下的第63个盘子移动到Z上，后面就是重复这一操作，直到剩一个盘子是，直接将该盘子由X移动到Z。

#include <stdio.h>
//第一要素：明确你这个函数想要干什么
// 函数功能：将 n 个盘子从 x 借助 y 移动到 z
void move(int n, char x, char y, char z) {
  //第二要素：寻找递归结束条件，当n=1时，直接将盘子从x移动到z
  if (1 == n) {
    printf("%c-->%c\n", x, z);
  } else {
    //第三要素：找出函数的等价关系式，并不考虑具体的移动过程，仅考虑完成任务
    move(n - 1, x, z, y);       // 将 n-1 个盘子从x借助z移到y上
    printf("%c-->%c\n", x, z);  // 将第n个盘子从x移到z上
    move(n - 1, y, x, z);       // 将 n-1 个盘子从y借助x移到z上
  }
}

int main() {
  int n;

  printf("请输入汉诺塔的层数: ");
  scanf("%d", &n);
  printf("移动的步骤如下: \n");
  move(n, 'X', 'Y', 'Z');

  return 0;
}