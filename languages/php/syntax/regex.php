<?php

$string = "上飞机离开我<img border='0' alt='' src='/uploadfile/2009/0921/20090921091612567.jpg'/>sdfsdf";

$su = preg_match("/ \<[ ]*img.*src[ ]*\=[ ]*[\"|\'](.+?)[\"|\'] /", $string, $match); // 匹配src=的内容
print_r($match[0]); // 输出 /uploadfile/2009/0921/20090921091612567.jpg

$su = preg_match("/ \<[ ]*img.*src[ ]*\=[ ]*[\"|\'](.+)[\"|\'] /", $string, $match);
print_r($match[0]); // 输出 /uploadfile/2009/0921/20090921091612567.jpg' border='


$str = preg_replace_callback(
    '/([a-z]*)([A-Z]*)/',
    function ($matchs) {
        return strtoupper($matchs[1]).strtolower($matchs[2]);
    },
    ['ab','AB','aB','Ab']
);
?>

用户名: ^[a-z0-9_-]{3,16}$
密码: ^[a-z0-9_-]{6,18}$
十六进制值: ^#?([a-f0-9]{6}|[a-f0-9]{3})$
电子邮箱: ^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$
URL: ^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-]*)*/?$
IP 地址: ^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$
HTML 标签: <([a-z]+)([<]+)*(?:>(.*)</\1>|\s+/>)$
Unicode编码中的汉字范围： ^[u4e00-u9fa5],{0,}$
匹配中文字符的正则表达式： [\u4e00-\u9fa5]
匹配双字节字符(包括汉字在内)： [^\x00-\xff]
匹配空白行的正则表达式： \n\s*\r
匹配HTML标记的正则表达式： <(\S*?)[^>]*>.*?</\1>|<.*? />
匹配首尾空白字符的正则表达式： ^\s*|\s*$
匹配Email地址的正则表达式： \w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*
匹配网址URL的正则表达式： [a-zA-z]+://[^\s]*
匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)： ^[a-zA-Z][a-zA-Z0-9_]{4,15}$
匹配国内电话号码： \d{3}-\d{8}|\d{4}-\d{7}
匹配腾讯QQ号： [1-9][0-9]{4,}
匹配中国大陆邮政编码： [1-9]\d{5}(?!\d)
匹配身份证： \d{15}|\d{18}
匹配ip地址： ((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)

^[1-9]\d*$　 　 //匹配正整数
^-[1-9]\d*$ 　 //匹配负整数
^-?[1-9]\d*$　　 //匹配整数
^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0）
^-[1-9]\d*|0$　　 //匹配非正整数（负整数 + 0）
^[1-9]\d*.\d*|0.\d*[1-9]\d*$　　 //匹配正浮点数
^-([1-9]\d*.\d*|0.\d*[1-9]\d*)$　 //匹配负浮点数
^-?([1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0)$　 //匹配浮点数
^[1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
^(-([1-9]\d*.\d*|0.\d*[1-9]\d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）
评注：处理大量数据时有用，具体应用时注意修正

^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串


如果你认真去看例4-1，发现那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。

正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|（竖线）把不同的规则分隔开

例5-1：0\d{2}-\d{8}|0\d{3}-\d{7}

分析：这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如：010-12345678)，一种是4位区号，7位本地号(如：0376-2233445)，0\d{2}-\d{8}表示“0”加两数字加“-”加8个数字，0\d{3}-\d{7}表示“0”加三数字加“-”加7个数字，|可理解为“或”。就是查找与前者相匹配或者与后者相匹配的内容。

注意：使用分枝条件时，要注意各个条件的顺序。因为匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。如：\d{5}-\d{4}|\d{5}和\d{5}|\d{5}-\d{4}是不同的。

* 分组：用小括号来指定子表达式，然后就可以指定这个子表达式的重复次数了 `(\d{1,3}.){3}\d{1,3}`

分析：这是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}\.) {3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字\d{1,3}。

不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。

* 反义
- \W  匹配任意不是字母，数字，下划线，汉字的字符
- \S  匹配任意不是空白符的字符
- \D  匹配任意非数字的字符
- \B  匹配不是单词开头或结束的位置
- [^x]    匹配除了x以外的任意字符
- [^aeiou]    匹配除了aeiou这几个字母以外的任意字符
* 后向引用：使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理
- 默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。
- 后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。

例8-1：\b(\w+)\b\s+\1\b

分析：可以匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字\b(\w+)\b，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符\s+，最后是分组1中捕获的内容（也就是前面匹配的那个单词）\1。


对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左至右所遇到的内容存储。存储子匹配的缓冲区编号从 1 开始，连续编号直至最大 99 个子表达式。每个缓冲区都可以使用 '\n' 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。

可以使用非捕获元字符 '?:', '?=', or '?!' 来忽略对相关匹配的保存。


